# 운영체제(OS)

## 메모리 관리

메모리를 효율적으로 사용하기 위해 Swapping을 활용하여 할당 시간이 끝난 메모리를 보조 기억 장치로 내보내고 다른 프로세스의 메모리를 불러온다. 하지만 swapping에는 큰 디스크 전송시간이 필요하기 때문에 메모리 공간이 부족할 경우 swapping을 실시한다. => 중기스케줄러

각각의 프로세스는 독립된 메모리 공간을 갖으며 다른 프로세스의 메모리 공간에 접근 할 수 없다

이때 메모리에 프로세스들이 올라가게되면 틈이 생기는 데 이를 단편화라 한다.

1. 외부 단편화

   ![외부단편화](./external_fragmentation)

   메모리 공간 중 사용하지 못하게 되는 일부분. 물리 메모리(RAM)에서 사이사이 남는 공간들을 모두 합치면 충분한 공간이 되는 부분들이 **분산되어 있을때 발생**

   외부 단편화를 해소하기 위해 압축을 활용하여 프로세스가 사용하는 공간을 한 공간으로 모아 자유공간을 확보하기도 하지만 효율이 좋지 않다.

2. 내부 단편화

   ![내부 단편화](./internal_fragmentation)

   프로세스가 사용하는 메모리 공간 에 포함된 남는 부분, 할당된 메모리 분할 자유 공간이 실제 올라간 프로세스보다 작을 때 낭비되는 공간이 생길때 발생

## 가상 메모리

다중 프로그래밍을 실현하기 위해서는 많은 프로세스들을 동시에 메모리에 올려두어야 한다. 하지만 가상 메모르는 프로세스 전체가 메모리에 올라가지 않더라도 실행을 할 수 있게 해준다.

여러 프로세스 동시 실행 시스템에서는 가상메모리가 필수적으로 필요하다.

- 메모리 용량 부족 이슈
- 프로세스 메모리 영역간에 침범 이슈

가상 메모리는 메모리 관리 장치(MMU)에 의해서 물리 주소로 변환된다. 이 덕분에 프로그래머는 가상 주소 공간상에서 프로그램을 짜게 되어 프로그램이나 데이터가 주메모리상에 어떻게 존재하는지를 의식할 필요가 없어진다.

* 물리 메모리 크기에 제약받지 않게 된다.
* 더 많은 프로그램을 동시에 실행할 수 있게 된다. 이에 따라 `응답시간`은 유지되고, `CPU 이용률`과 `처리율`은 높아진다.
* swap에 필요한 입출력이 줄어들기 때문에 프로그램들이 빠르게 실행된다.
* `시스템 라이브러리`가 여러 프로세스들 사이에 공유될 수 있도록 한다. 각 프로세스들은 `공유 라이브러리`를 자신의 가상 주소 공간에 두고 사용하는 것처럼 인식하지만, 라이브러리가 올라가있는 `물리 메모리 페이지`들은 모든 프로세스에 공유되고 있다.
* 프로세스들이 메모리를 공유하는 것을 가능하게 하고, 프로세스들은 공유 메모리를 통해 통신할 수 있다. 이 또한, 각 프로세스들은 각자 자신의 주소 공간처럼 인식하지만, 실제 물리 메모리는 공유되고 있다.
* `fork()`를 통한 프로세스 생성 과정에서 페이지들이 공유되는 것을 가능하게 한다.

## 가상 메모리 관리 기법

1. 페이징(paging)

   외부 단편화와 압축 작업을 해소 하기 위해 생긴 방법론으로, 물리 메모리는 Frame 이라는 고정 크기로 분리되어 있고, 논리 메모리(프로세스가 점유하는)는 페이지라 불리는 고정 크기의 블록으로 분리된다

   - 페이징 방식에서는 가상메모리상의 주소공간을 일정한 크기의 페이지로 분할하게 되는데 실제 메모리 또한 가상메모리와 같은 크기로 페이지를 분할한다.
   - 페이지의 크기는 대부분 4Kbyte를 사용한다.
   - 크기가 동일한 페이지로 가상 주소 공간과 이에 매칭하는 물리 주소 공간을 관리

   페이징 기법을 사용함으로써 논리 메모리는 물리 메모리에 저장될 때, 연속되어 저장될 필요가 없고 물리 메모리의 남는 프레임에 적절히 배치됨으로 외부 단편화를 해결할 수 있는 큰 장점이 있다.

   내부 단편화 문제의 비중이 늘어나게 된다. 일정한 크기로 프레임을 잘라 운영하기 때문에 남는 공간이 발생하며 이는 내부 단편화 문제를 야기시킨다.

2. 세그멘테이션(segmentation)

   논리 메모리와 물리 메모리를 같은 크기의 블록이 아닌, 서로 다른 크기의 논리적 단위인 세그먼트(Segment)로 분할 사용자가 두 개의 주소로 지정(세그먼트 번호 + 변위) 세그먼트 테이블에는 각 세그먼트의 기준(세그먼트의 시작 물리 주소)과 한계(세그먼트의 길이)를 저장한다.

   서로 다른 크기의 세그먼트들이 메모리에 적재되고 제거되는 일이 반복되다 보면, 자유 공간들이 많은 수의 작은 조각들로 나누어져 못 쓰게 될 수도 있다. 때문에 외부 단편화 문제는 야기시킨다.

3. 요구 페이징(demand paging)

   프로그램 전체를 디스크에서 물리 메모리에 적재하는 대신, 초기에 필요한 것들만 적재하는 전략을 요구 페이징이라 한다.

   요구 페이징을 사용하는 가상 메모리에서는 실행과정에서 필요해질 때 페이지들이 적재된다. **한 번도 접근되지 않은 페이지는 물리 메모리에 적재되지 않는다.**

## 페이지 교체

프로그램 실행시에 모든 항목이 물리 메모리에 올라오지 않기 때문에, 프로세스의 동작에 필요한 페이지를 요청하는 과정에서 `page fault(페이지 부재)`가 발생하게 되면, 원하는 페이지를 보조저장장치에서 가져오게 된다. 하지만, 만약 물리 메모리가 모두 사용중인 상황이라면, 페이지 교체가 이뤄져야 한다.

1. 디스크에서 필요한 페이지의 위치를 찾는다
2. 빈 페이지 프레임을 찾는다.
   1. `페이지 교체 알고리즘`을 통해 희생될(victim) 페이지를 고른다.
   2. 희생될 페이지를 디스크에 기록하고, 관련 페이지 테이블을 수정한다.
3. 새롭게 비워진 페이지 테이블 내 프레임에 새 페이지를 읽어오고, 프레임 테이블을 수정한다.
4. 사용자 프로세스 재시작

### 페이지 교체 알고리즘

##### 최적 페이지 교체(Optimal Page Replacement)

알고리즘의 핵심은 `앞으로 가장 오랫동안 사용되지 않을 페이지를 찾아 교체`하는 것이다. 주로 비교 연구 목적을 위해 사용한다.

##### FIFO 페이지 교체

가장 간단한 페이지 교체 알고리즘으로 FIFO(first-in first-out)의 흐름을 가진다. 즉, 먼저 물리 메모리에 들어온 페이지 순서대로 페이지 교체 시점에 먼저 나가게 된다는 것이다.

##### LRU 페이지 교체(Least-Recently-Used Page Replacement)

가장 오랫동안 사용되지 않은 페이지를 선택하여 교체한다.

##### LFU 페이지 교체(Least Frequently Used Page Replacement)

참조 횟수가 가장 적은 페이지를 교체하는 방법이다. 활발하게 사용되는 페이지는 참조 횟수가 많아질 거라는 가정에서 만들어진 알고리즘이다.

##### MFU 페이지 교체(Most Frequently Used Page Replacement)

참조 회수가 가장 작은 페이지가 최근에 메모리에 올라왔고, 앞으로 계속 사용될 것이라는 가정에 기반한다.
